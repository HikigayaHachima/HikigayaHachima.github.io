{"meta":{"title":"比起谷八幡","subtitle":null,"description":"技术宅的自闭之旅","author":"大老师","url":"https://hikigayahachima.github.io"},"pages":[{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-05-16T14:39:12.000Z","comments":false,"path":"bangumi/index.html","permalink":"https://hikigayahachima.github.io/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-05-16T14:39:12.000Z","comments":false,"path":"client/index.html","permalink":"https://hikigayahachima.github.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-05-16T14:39:12.000Z","comments":false,"path":"donate/index.html","permalink":"https://hikigayahachima.github.io/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-05-21T10:33:30.173Z","comments":true,"path":"comment/index.html","permalink":"https://hikigayahachima.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-05-16T14:39:12.000Z","comments":false,"path":"lab/index.html","permalink":"https://hikigayahachima.github.io/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-05-16T14:39:12.000Z","comments":true,"path":"links/index.html","permalink":"https://hikigayahachima.github.io/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-05-16T14:39:12.000Z","comments":true,"path":"tags/index.html","permalink":"https://hikigayahachima.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-05-16T14:39:12.000Z","comments":false,"path":"about/index.html","permalink":"https://hikigayahachima.github.io/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... function bot_ui_ini() { var botui = new BotUI(\"hello-mashiro\"); botui.message.add({ delay: 800, content: \"Hi, there111👋\" }).then(function () { botui.message.add({ delay: 1100, content: \"这里是 Mashiro\" }).then(function () { botui.message.add({ delay: 1100, content: \"一个可爱的蓝孩子~\" }).then(function () { botui.action.button({ delay: 1600, action: [{ text: \"然后呢？ 😃\", value: \"sure\" }, { text: \"少废话！ 🙄\", value: \"skip\" }] }).then(function (a) { \"sure\" == a.value && sure(); \"skip\" == a.value && end() }) }) }) }); var sure = function () { botui.message.add({ delay: 600, content: \"😘\" }).then(function () { secondpart() }) }, end = function () { botui.message.add({ delay: 600, content: \"![...](https://view.moezx.cc/images/2018/05/06/a1c4cd0452528b572af37952489372b6.md.jpg)\" }) }, secondpart = function () { botui.message.add({ delay: 1500, content: \"目前就读于上海财经大学\" }).then(function () { botui.message.add({ delay: 1500, content: \"向往技术却误入商科，但后来喜欢上了经济学…\" }).then(function () { botui.message.add({ delay: 1200, content: \"因为数据分析也需要Coder嘛\" }).then(function () { botui.message.add({ delay: 1500, content: \"主攻 R 语言和 Python，略懂 STATA，偶尔也折腾 HTML/CSS/JavaScript/PHP\" }).then(function () { botui.message.add({ delay: 1500, content: \"研究的方向，是经济/金融方向的数据分析（data science）以及机器学习（machine learning）\" }).then(function () { botui.message.add({ delay: 1800, content: \"喜欢画画，希望有一天能够被称为画师\" }).then(function () { botui.action.button({ delay: 1100, action: [{ text: \"为什么叫Mashiro呢？ 🤔\", value: \"why-mashiro\" }] }).then(function (a) { thirdpart() }) }) }) }) }) }) }) }, thirdpart = function () { botui.message.add({ delay: 1E3, content: \"Mashiro以及站名都来自一部动画，因为和主角有一样的爱好~ 如果有兴趣可以找找首页上的视频~\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"为什么是白猫呢？ 🤔\", value: \"why-cat\" }] }).then(function (a) { fourthpart() }) }) }, fourthpart = function () { botui.message.add({ delay: 1E3, content: \"因为对GitHub有种执念… \" }).then(function () { botui.message.add({ delay: 1100, content: \"而且我真的是猫控！\" }).then(function () { botui.action.button({ delay: 1500, action: [{ text: \"域名有什么含意吗？(ง •_•)ง\", value: \"why-domain\" }] }).then(function (a) { fifthpart() }) }) }) }, fifthpart = function () { botui.message.add({ delay: 1E3, content: \"emmmm，看备案信息你就知道了=.= 本来想要zheng.xin的，但50万真买不起。。\" }).then(function () { botui.message.add({ delay: 1600, content: \"那么，仔细看看我的博客吧？ ^_^\" }) }) } } bot_ui_ini()","keywords":"关于"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-05-16T14:39:12.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"https://hikigayahachima.github.io/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-05-16T14:39:12.000Z","comments":false,"path":"music/index.html","permalink":"https://hikigayahachima.github.io/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-05-16T14:39:12.000Z","comments":true,"path":"rss/index.html","permalink":"https://hikigayahachima.github.io/rss/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-05-16T14:39:12.000Z","comments":false,"path":"video/index.html","permalink":"https://hikigayahachima.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"3D动画的理解","slug":"3D动画的理解","date":"2019-06-15T01:25:34.000Z","updated":"2019-06-15T03:19:53.303Z","comments":true,"path":"2019/06/15/3D动画的理解/","link":"","permalink":"https://hikigayahachima.github.io/2019/06/15/3D动画的理解/","excerpt":"","text":"&emsp;&emsp;css3是一个很有意思的改革，他在我们原有网页的2D基础上，通过perspective: 距离;的方法添加一个视觉景深效果，让2D的平面变得有3D的视觉效果，通过transform-style: preserve-3d;的方法来实现页面的3D布局，我先上这两种类型的代码实现效果之间的区别，再慢慢讲解： perspective: 距离;&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; a{ text-decoration: none; color: white; } #box{ margin: 100px auto 0 auto; padding: 0px; height: 187px; width: 216px; position: relative; perspective:1000px; } #pic,#text{ width: 216px; height: 187px; } #pic{ position: absolute; background: url(https://i.loli.net/2019/06/15/5d0455dca316f22967.jpg); transition:0.5s; } #box:hover #text{ transform:rotateY(0deg); } #box:hover #pic{ transform:rotateY(-90deg); } #text{ background-color: rgba(0,0,0,0.7); text-align: center; line-height: 187px; position: absolute; transform:rotateY(90deg); transition:0.5s; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;pic&quot;&gt;&lt;/div&gt; &lt;div id=&quot;text&quot;&gt;&lt;a href=&quot;&quot;&gt; 你给俺等着，哼哼~ &lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; transform-style: preserve-3d;&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *{ margin: 0px; padding: 0px; } .content{ height: 200px; background-color: #63B8FF; margin-top: 200px; } .box{ width: 200px; height: 200px; margin: 0 auto; position: relative; transform:rotateY(45deg) rotateX(45deg); transform-style: preserve-3d; animation:xuanzhuan 10s infinite alternate; } .box div{ height: 200px; width: 200px; position: absolute; line-height: 200px; text-align: center; font-size: 30px; transition: transform 0.3s; } .box .box_fornt{ background-color: rgba(154,50,205,0.7); transform:rotateY(0deg) translateZ(100px); } .box .box_back{ background-color: rgba(238,58,140,0.7); transform:rotateY(0deg) translateZ(-100px); } .box .box_left{ background-color: rgba(122,103,238,0.7); transform:rotateY(90deg) translateZ(-100px); } .box .box_right{ background-color: rgba(255,69,0,0.7); transform:rotateY(90deg) translateZ(100px); } .box .box_top{ background-color: rgba(255,165,0,0.7); transform:rotateX(90deg) translateZ(100px); } .box .box_bottom{ background-color: rgba(0,255,127,0.7); transform:rotateX(90deg) translateZ(-100px); } /* inner box */ .box i{ width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; margin-top: -50px; margin-left: -50px; line-height: 100px; text-align: center; font-size: 20px; } .box .inner_fornt{ background-color: rgba(154,50,205,0.7); transform:rotateY(0deg) translateZ(50px); } .box .inner_back{ background-color: rgba(238,58,140,0.7); transform:rotateY(0deg) translateZ(-50px); } .box .inner_left{ background-color: rgba(122,103,238,0.7); transform:rotateY(90deg) translateZ(-50px); } .box .inner_right{ background-color: rgba(255,69,0,0.7); transform:rotateY(90deg) translateZ(50px); } .box .inner_top{ background-color: rgba(255,165,0,0.7); transform:rotateX(90deg) translateZ(50px); } .box .inner_bottom{ background-color: rgba(0,255,127,0.7); transform:rotateX(90deg) translateZ(-50px); } /* hover box */ .box:hover .box_fornt{ transform:rotateY(0deg) translateZ(200px); } .box:hover .box_back{ transform:rotateY(0deg) translateZ(-200px); } .box:hover .box_left{ transform:rotateY(90deg) translateZ(-200px); } .box:hover .box_right{ transform:rotateY(90deg) translateZ(200px); } .box:hover .box_top{ transform:rotateX(90deg) translateZ(200px); } .box:hover .box_bottom{ transform:rotateX(90deg) translateZ(-200px); } @keyframes xuanzhuan{ from{ transform:rotateY(0deg) rotateX(0deg) } to{ transform:rotateY(360deg) rotateX(360deg) } } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;box_fornt&quot;&gt;正面&lt;/div&gt; &lt;div class=&quot;box_back&quot;&gt;背面&lt;/div&gt; &lt;div class=&quot;box_left&quot;&gt;左面&lt;/div&gt; &lt;div class=&quot;box_right&quot;&gt;右面&lt;/div&gt; &lt;div class=&quot;box_top&quot;&gt;上面&lt;/div&gt; &lt;div class=&quot;box_bottom&quot;&gt;下面&lt;/div&gt; &lt;i class=&quot;inner_fornt&quot;&gt;正面&lt;/i&gt; &lt;i class=&quot;inner_back&quot;&gt;背面&lt;/i&gt; &lt;i class=&quot;inner_left&quot;&gt;左面&lt;/i&gt; &lt;i class=&quot;inner_right&quot;&gt;右面&lt;/i&gt; &lt;i class=&quot;inner_top&quot;&gt;上面&lt;/i&gt; &lt;i class=&quot;inner_bottom&quot;&gt;下面&lt;/i&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &emsp;&emsp;这两个属性的最大区别，在于 &emsp;&emsp;perspective是给物体一个视角，但是物体本事还是2D的东西，就好比一张纸的翻转，你会看到越靠近的越大，越远的越小，它的本质并不是3D布局，顶多算是伪3D。就如上述代码中，我们设置了perspective:1000px;看到的效果是有一种3D的感觉，但它却不能实现多个面拼接成真实的3D模型 &emsp;&emsp;transform-style: preserve-3d;是真正的，赋予页面3D布局能力的属性，只要声明了这个属性，页面的布局就可以用拼接的方法，实现立体的效果，比如上述代码的正方体，就是用6个面，在3D布局的页面上拼接而成，先让正方形重叠在一起，通过transform:rotateY(旋转角度) translateZ(平移距离);来实现6个面的拼接 &emsp;&emsp;在2d转换模块中我们研究了rotateX()和rotateY()方法，就是绕x轴和y轴旋转，这其实就是3d模块的一种表现，当然要看到近大远小的3d效果，还需要在父元素上添加透视属性：perspective:1000px;值为透视点到元素的距离，但是，你会发现当父元素转到90度的时候元素消失了，这就说明元素是没有厚度的。说明元素虽然具有了近大远小的透视属性，但本质上仍是2d的。你需要添加transform-style:preserve-3d;样式来让元素在3d空间中转换。这样，元素就处在了3维的空间里，当父元素旋转90度，仍能看到里面的子元素。","categories":[{"name":"技术","slug":"技术","permalink":"https://hikigayahachima.github.io/categories/技术/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://hikigayahachima.github.io/tags/javaScript/"},{"name":"悦读","slug":"悦读","permalink":"https://hikigayahachima.github.io/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://hikigayahachima.github.io/categories/技术/"}]},{"title":"好玩的C3动画","slug":"好玩的C3动画","date":"2019-05-20T06:00:32.000Z","updated":"2019-06-14T10:46:10.949Z","comments":true,"path":"2019/05/20/好玩的C3动画/","link":"","permalink":"https://hikigayahachima.github.io/2019/05/20/好玩的C3动画/","excerpt":"","text":"​&emsp;&emsp;首先说c3动画，就必须提到animation 这个就相当于咱们写的background的一样，是一个c3新增的属性。这个就能写动画了。我想你们只要玩过游戏，一定知道“FPS”这个东西，这就是帧数。这个是动画的一个过程，电脑是根据帧，然后渲染得到的一个连续的动画。看一小段代码： /* * animation-name 规定需要绑定到选择器的 keyframe 名称。。 * animation-duration 规定完成动画所花费的时间，以秒或毫秒计。 * animation-timing-function 规定动画的速度曲线。 * animation-delay 规定在动画开始之前的延迟。 * animation-iteration-count 规定动画应该播放的次数。 * animation-direction 规定是否应该轮流反向播放动画。 */ &emsp;&emsp;这里附上一个W3C链接地址，里面有各个属性的属性值。点这里 ​&emsp;&emsp;回到咱们上个问题，就是点击这个按钮的时候，需要将这个动画暂停，然后再次点击的时候开始这个动画。这个时候就需要用到一个叫做“animation-play-state”的属性了，他的属性值我们可以设置为“paused”。当然了实际的生产中，我们肯定是会给这个属性一个class类名的，然后通过控制这个class类名的添加和删除，来控制这个动画的暂停和开始。请看下面的一行css代码： .pause { animation-play-state: paused; } ​&emsp;&emsp;按钮设计好了，接下来就是具体的css样式代码，废话不多，先上代码，我们再慢慢看： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;css3 动画&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot; /&gt; &lt;style type=&quot;text/css&quot;&gt; @keyframes myfirst{ from { background: red; left: 0px; top: 40px; border-radius: 0; transform:rotate(0deg); } to { background: blue; left: 300px; top: 200px; border-radius: 50%; transform:rotate(360deg); } } .dong{ animation: myfirst 2s linear 0s infinite alternate; } /* * animation-name 规定需要绑定到选择器的 keyframe 名称。。 * animation-duration 规定完成动画所花费的时间，以秒或毫秒计。 * animation-timing-function 规定动画的速度曲线。 * animation-delay 规定在动画开始之前的延迟。 * animation-iteration-count 规定动画应该播放的次数。 * animation-direction 规定是否应该轮流反向播放动画。 */ .pause { animation-play-state: paused; } .big_box{ width: 100px; height: 100px; background: red; text-align: center; line-height: 100px; position: absolute; left: 0px; top: 40px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;big_box&quot;&gt;一个盒子&lt;/div&gt; &lt;button class=&quot;button1&quot;&gt;开始&lt;/button&gt; &lt;button class=&quot;button2&quot;&gt;暂停&lt;/button&gt; &lt;/body&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;.button2&quot;).attr(&quot;disabled&quot;,true); $(&quot;.button1&quot;).on(&quot;click.animation&quot;,function(){ //点击按钮添加class 为 dong $(&quot;.big_box&quot;).addClass(&quot;dong&quot;); $(&quot;.button2&quot;).attr(&quot;disabled&quot;,false); }) $(&quot;.button2&quot;).on(&quot;click.pause&quot;,function(){ //点击按钮删除pause类 $(&quot;.big_box&quot;).toggleClass(&quot;pause&quot;); }) &lt;/script&gt; &lt;/html&gt; &emsp;&emsp;我一直觉得，c3的animation动画和js的函数很相像，都需要先声明动画，然后再调用动画。比如上面这个，我们需要通过关键帧@keyframes来创建一个动画区域，里面录入了动画各个阶段索要改变的属性和改变的值，然后通过animation来调用这个动画。 &emsp;&emsp;c3动画不仅能改变内容的各种宽高，边角，旋转等样式，它还可以渐变颜色，就像上面，我只用在开始写个red，在结尾写个blue，就可以简单的实现红色到蓝色的渐变，这点是js完全做不到的。 &emsp;&emsp;现代浏览器在使用CSS3动画时，以下四种情形绘制的效率较高，分别是： 改变位置 改变大小 旋转 改变透明度 &emsp;&emsp;咳咳~上面说了c3动画的那么多好处，那他到底有哪些不足的地方？ 1）性能差距​&emsp;&emsp;既然说到性能那肯定又要说道浏览器的重绘，回流还有重布局。这样就很麻烦了，而且动画不只有css的动画，jquery也提供了一套动画。JS动画和CSS3动画的比较 我们经常面临一个抉择：是使用JavaScript的动画还是使用CSS的动画，下面将对比一下这两种方式 JS动画缺点：JavaScript在浏览器的主线程中运行，而其中还有很多其他需要运行的JavaScript、样式计算、布局、绘制等对其干扰。这也就导致了线程可能出现阻塞，从而造成丢帧的情况。 优点：JavaScript的动画与CSS预先定义好的动画不同，可以在其动画过程中对其进行控制：开始、暂停、回放、中止、取消都是可以做到的。而且一些动画效果，比如视差滚动效果，只有JavaScript能够完成 CSS动画缺点：缺乏强大的控制能力。而且很难以有意义的方式结合到一起，使得动画变得复杂且易于出问题。 优点：浏览器可以对动画进行优化。它必要时可以创建图层，然后在主线程之外运行。 2）兼容性差距css3的动画属性兼容性还是比较好的，大部分的浏览器都能运行，但是肯定没有js动画兼容性高，这毋庸置疑，所以在写css3动画时尽量使用比较常用的属性 结论&emsp;&emsp;动画给予了页面丰富的视觉体验。我们应该尽力避免使用会触发重布局和重绘的属性，以免失帧。最好提前申明动画，这样能让浏览器提前对动画进行优化。由于GPU的参与，现在用来做动画的最好属性是如下几个： opacity translate rotate scale &emsp;&emsp;最后给两个我认为写的不错的性能差距的文章，提供给有需要的朋友。点这里，还有这一个","categories":[{"name":"技术","slug":"技术","permalink":"https://hikigayahachima.github.io/categories/技术/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://hikigayahachima.github.io/tags/javaScript/"},{"name":"悦读","slug":"悦读","permalink":"https://hikigayahachima.github.io/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://hikigayahachima.github.io/categories/技术/"}]},{"title":"五子棋--AI篇","slug":"五子棋-AI篇","date":"2019-05-20T06:00:32.000Z","updated":"2019-06-14T10:39:46.869Z","comments":true,"path":"2019/05/20/五子棋-AI篇/","link":"","permalink":"https://hikigayahachima.github.io/2019/05/20/五子棋-AI篇/","excerpt":"","text":"简介AI篇写的真的是让人头秃，虽然我觉得工作用不上三维数组，根本没怎么练习过，导致AI篇的算法写的人头皮发麻，基本全卡在算法上，真正的逻辑却没有多少，总之还是介绍一下吧 整体思路注意：本片是基于UI篇的后续开发，所以请务必观看UI篇后再来看此篇 赢法数组用一个三维的数组记录五子棋的所有赢法。 每种赢法的统计数组我们用一维数组来记录每种赢法 如何判断输赢判断输赢的方法 实现计算机落子这部分是重点，算法设计精准，计算机的棋艺就高 内容区赢法数组首先定义一个三维的数组，用于存放所有赢的情况。 //赢法数组 var wins = []; for(var i=0; i&lt;15; i++){ wins[i] = []; for(var j=0; j&lt;15; j++){ wins[i][j] = []; } } 定义count用于记录赢的方法种类数量，然后再遍历所有赢的情况，包括横向、纵向、斜向、反斜向，下面以横向为例讲解。 //统计所有可能的赢法 var count = 0; //横线 for(var i = 0; i &lt; 15; i++){ for(var j= 0; j &lt; 11; j++){ for(var k = 0; k &lt; 5; k++){ wins[i][j+k][count] = true; } count++; } } 这是五个棋子呈横的形式赢的情况。 这里有三个循环，第一个循环是指每一条横线。第二个循环指的是摆成五个子，第一个子的纵坐标。第三个循环是摆满五个棋子，里重点说说为什么j&lt;11。如果你想更好地理解，可以代些数进去看一下是什么情况。 如果j=10时，赢的情况是如下图： 如果j还比10大的话就会超出棋盘。 以此类推，纵向、斜向、反斜向也是同理： //统计所有可能的赢法 var count = 0; //横线 for(var i = 0; i &lt; 15; i++){ for(var j= 0; j &lt; 11; j++){ for(var k = 0; k &lt; 5; k++){ wins[i][j+k][count] = true; } count++; } } //竖线 for(var i = 0; i &lt; 15; i++){ for(var j= 0; j &lt; 11; j++){ for(var k = 0; k &lt; 5; k++){ wins[j+k][i][count] = true; } count++; } } //正斜 for(var i = 0; i &lt; 11; i++){ for(var j= 0; j &lt; 11; j++){ for(var k = 0; k &lt; 5; k++){ wins[i+k][j+k][count] = true; } count++; } } //反斜 for(var i = 0; i &lt; 11; i++){ for(var j= 14; j &gt; 3; j--){ for(var k = 0; k &lt; 5; k++){ wins[i+k][j-k][count] = true; } count++; } } //console.log(count) 15*15的棋盘中有572中赢法 最后在后台输出总共有多少种赢法。我们由此知道，15*15的棋盘总共有572种赢法，所有赢法计算机都知道了，所以，如果代码打得好，你根本无法赢机器。 赢法的统计数组这是一个一维的数组，用来计算某种赢法是否达成。上面列举了所有的赢法，那在某赢法中成功落下一个棋子，那我们就为该种赢法的值加1，直到加5就实现了此种赢法，实现结束游戏。那如果该赢法中有另一方的棋子，此种赢法报废。大概就是这么一个思路。计算机落子的目的就是去破坏你某种赢法的可行性，所以计算机落子的风格跟人有很大的区别。 定义并实例化两个数组，一个用来存放玩家赢法的数组，另一个用来存放电脑赢法的数组。 还定义了一个over变量，标志游戏是否结束。 //判断结束游戏 var over = false; //输赢统计数组 var my_win = []; var computer_win = []; //用来统计有多少个子连成一线 for (let i = 0; i &lt; count; i++) { my_win[i] = 0; computer_win[i] = 0; } 在单击事件，成功落子后进行一个循环。 这个循环遍历所有的赢法，如果某种赢法里有棋子，就my_win[k]++，如果my_win[k] == 5成立了，改变over的标志，就代表你赢了 canvas.onclick = function (e){ if(over){//判断游戏是否结束 return ; } var x = e.offsetX ; var y = e.offsetY ; var i = Math.floor(x/30) ; var j = Math.floor(y/30) ; if(canvasBoard[i][j] == 0){ //为0时，证明这个位置是空的，是可以落子的 on(i,j,me); if(me == true){ canvasBoard[i][j] = 1 ; //用1来表示我的落子 }else{ canvasBoard[i][j] = 2 ; //用2来表示电脑的落子 } me = false ; //落下子后需要进行统计 for(var k=0; k&lt;count; k++){ if(wins[i][j][k]){ //如果我当前落子符合某个赢法 my_win[k]++; //离胜利又进一步 computer_win[k] = 6 ; //该种赢法计算机没有机会了 if(my_win[k] == 5){ //如果达到5就赢了 window.alert(&quot;you win!!&quot;); over = true ; //游戏结束 } } } } } 测试，如下图所示，如果你下够五个子，就弹窗提示你赢了，这里有点不好，就是你要点击确认，第五个棋子才出来，后面会进行优化。 计算机判断有效落棋点在完成落子统计后判断是否结束游戏，如果没结束，就轮到计算机下棋，计算棋下棋调用computerAI()方法。 if(over == false){ me = false ; //如果游戏没结束，下棋权利交给计算机 computerAI();//计算机AI } 在点击鼠标的时候需要判断是否轮到人落棋： if(me == false){ //如果为false时，还没轮到我下棋，return个空气出去，让我动不了 return; } 更改落棋的判断，如果鼠标点击，只下黑棋，并且只改变黑棋的频数统计。 if(canvasBoard[i][j] == 0){ //当前区域没有子 on(i,j,me); //先落子 canvasBoard[i][j] = 1 ; //在标注1证明是我的子 //落下子后需要进行统计 for(var k=0; k&lt;count; k++){ if(wins[i][j][k]){ //某种赢的某子true my_win[k]++; //离胜利又进一步 computer_win[k] = 6 ; //该种赢法计算机没有机会了 if(my_win[k] == 5){ //如果达到5就赢了 window.alert(&quot;厉害，你赢了！！&quot;); over = true ; } } } if(over == false){ me = false ; //如果游戏没结束，下棋权利交给计算机 computerAI();//计算机AI } } 接下来实现computerAI()方法的棋步权值，这是整篇的难点，先上代码： var computerAI = function(){ //积分设定 var myScroe = []; var computerScore = []; //落子的优先判定 var max = 0; //电脑的落子坐标 var u = 0,v = 0; //获得所有的格子,每个格子都有myScroe和computerScore且都为0用来给落子打分 for (let i = 0; i &lt; 15; i++) { myScroe[i] = []; computerScore[i] = []; for (let j = 0; j &lt; 15; j++) { myScroe[i][j] = 0; computerScore[i][j] = 0; } } //先获得每一个格子 for (let i = 0; i &lt; 15; i++){ for (let j = 0; j &lt; 15; j++){ //和人下棋一样,落子前得判定canvasBoard[i][j]为0,也就是没有任何棋子 if(canvasBoard[i][j] == 0){ //遍历全部的赢法 for (let k = 0; k &lt; count; k++){ //如果当前的wins[i][j][k]存在,并且有子的时候 if (wins[i][j][k]){ //接下来就是具体给每个落子打分 //每存在一种情况，就给myScroe[i][j]加上对应的分数 if (my_win[k] == 1){ myScroe[i][j] += 200; } else if(my_win[k] == 2){ myScroe[i][j] += 400; } else if(my_win[k] == 3){ myScroe[i][j] += 2000; } else if(my_win[k] == 4){ myScroe[i][j] += 10000; } //这里是给电脑落子打分，同上 if (computer_win[k] == 1){ computerScore[i][j] += 300; } else if(computer_win[k] == 2){ computerScore[i][j] += 600; } else if(computer_win[k] == 3){ computerScore[i][j] += 4000; } else if(computer_win[k] == 4){ computerScore[i][j] += 20000; } } } } } } } 看到这些括号是不是头都大了，哈哈，其实逻辑不是很难，只要是算法有点烦。 如上代码，首先定义并实例化myScore[]与computerScore[]两个数组，用于存放各个棋点的落子价值，再分别遍历人和计算机的所有赢法，如果有1、2、3、4子，分别为棋点附权值。 实现计算机落子接下来我们找到计算机落子的最佳坐标，然后在这个坐标上落子，就实现了计算机落子的功能了，在这里把整个computerAI()函数贴出来再进行讲解： var computerAI = function(){ //积分设定 var myScroe = []; var computerScore = []; //落子的优先判定 var max = 0; //电脑的落子坐标 var u = 0,v = 0; //获得所有的格子,每个格子都有myScroe和computerScore且都为0用来给落子打分 for (let i = 0; i &lt; 15; i++) { myScroe[i] = []; computerScore[i] = []; for (let j = 0; j &lt; 15; j++) { myScroe[i][j] = 0; computerScore[i][j] = 0; } } //先获得每一个格子 for (let i = 0; i &lt; 15; i++){ for (let j = 0; j &lt; 15; j++){ //和人下棋一样,落子前得判定canvasBoard[i][j]为0,也就是没有任何棋子 if(canvasBoard[i][j] == 0){ //遍历全部的赢法 for (let k = 0; k &lt; count; k++){ //如果当前的wins[i][j][k]存在,并且有子的时候 if (wins[i][j][k]){ //接下来就是具体给每个落子打分 if (my_win[k] == 1){ myScroe[i][j] += 200; } else if(my_win[k] == 2){ myScroe[i][j] += 400; } else if(my_win[k] == 3){ myScroe[i][j] += 2000; } else if(my_win[k] == 4){ myScroe[i][j] += 10000; } //这里是给电脑落子打分 if (computer_win[k] == 1){ computerScore[i][j] += 300; } else if(computer_win[k] == 2){ computerScore[i][j] += 600; } else if(computer_win[k] == 3){ computerScore[i][j] += 4000; } else if(computer_win[k] == 4){ computerScore[i][j] += 20000; } } } //这段时用来判断落子的最佳处 //人在某一部权值更高的情况 if(myScroe[i][j] &gt; max){ max = myScroe[i][j]; u = i; v = j; } //权值已经到了最大的时候 else if(myScroe[i][j] == max){ //而i,j点的权值比在u,v点的更大时 if(computerScore[i][j] &gt; computerScore[u][v]){ u = i; v = j; } } //电脑在某一步权值更高时 else if(computerScore[i][j] &gt; max){ max = computerScore[i][j]; u = i; v = j; } //当权值最大的时候 else if(computerScore[i][j] == max){ //如果人电脑在此处落子更有用 if(myScroe[i][j] &gt; myScroe[u][v]){ u = i; v = j; } } } } } //当判断出最佳的落子点后,电脑开始落子,并且给落子点标记个2证明时白子 on(u,v,me); canvasBoard[u][v] = 2; //这里判断是否有五个子连成一线,和上面的判断大致一样 var b = setTimeout(() =&gt; { for (let k = 0; k &lt; count; k++) { if(wins[u][v][k]){ computer_win[k]++; my_win[k] = 6; if (computer_win[k] == 5) { on(u,v,me); over = true var a = setTimeout(() =&gt; { window.alert(&quot;you lose!!&quot;) clearTimeout(a); }, 30); } } } if(over == false){ me = true; } clearTimeout(b); }, 10); } 上面函数的代码比较长，其实很多一部分都是与上面有重复的。为了找到棋盘坐标最高权值和其坐标点，这里定义三个变量max、u和v 。通过上遍历所有赢法的值后，这里只要判断比较在哪一方的赢法中落子价值大，主要是自己向着赢的方向前进和不让对方赢的方向进行阻挡。如下面是比较的权值的代码，通过以下代码得到（u,v）这个权值最大的坐标： //这段时用来判断落子的最佳处 //人在某一部权值更高的情况 if(myScroe[i][j] &gt; max){ max = myScroe[i][j]; u = i; v = j; } //权值已经到了最大的时候 else if(myScroe[i][j] == max){ //而i,j点的权值比在u,v点的更大时 if(computerScore[i][j] &gt; computerScore[u][v]){ u = i; v = j; } } //电脑在某一步权值更高时 else if(computerScore[i][j] &gt; max){ max = computerScore[i][j]; u = i; v = j; } //当权值最大的时候 else if(computerScore[i][j] == max){ //要是电脑在此处落子更有用 if(myScroe[i][j] &gt; myScroe[u][v]){ u = i; v = j; } } 得到最大权值的坐标后，我们就要实现在该位置落子： 落完子后要对落子的位置进行统计，如果达到赢的情况就终止游戏，否则把落子权交给鼠标。 //当判断出最佳的落子点后,电脑开始落子,并且给落子点标记个2证明时白子 on(u,v,me); canvasBoard[u][v] = 2; //这里判断是否有五个子连成一线,和上面的判断大致一样 var b = setTimeout(() =&gt; { for (let k = 0; k &lt; count; k++) { if(wins[u][v][k]){ computer_win[k]++; my_win[k] = 6; if (computer_win[k] == 5) { on(u,v,me); over = true var a = setTimeout(() =&gt; { window.alert(&quot;you lose!!&quot;) clearTimeout(a); }, 30); } } } if(over == false){ me = true; } clearTimeout(b); }, 10); 到这里，游戏基本上是大功告成了，还记得之前有个优化没做好吗，其实给它加上定时器就能完美解决这类问题了，至于具体的原理，那就要深入到宏队列微队列以及执行栈了，这里就不做细讲，感兴趣的朋友可以去百度上看看大牛们的见解，下面是全部的js代码： &lt;script&gt; //获取地图画布 var canvas = document.querySelector(&quot;#map&quot;); var map = canvas.getContext(&quot;2d&quot;); map.strokeStyle = &quot;#111&quot;; //刻画棋盘 function context(){ for (let i = 0; i &lt; 15; i++) { //横线 map.moveTo(15,15+i*30); map.lineTo(435,15+i*30); map.stroke(); //竖线 map.moveTo(15+i*30,15); map.lineTo(15+i*30,435); map.stroke(); } } //增添背景图 var img = document.createElement(&quot;img&quot;); img.src = &quot;./images/qipan.jpg&quot;; img.onload = function(){ map.drawImage(img,0,0,450,450) context(); } //封装落子 function on(i,j,me){ map.beginPath(); //可以理解为棋子刻画开始 map.arc( //用于创建圆或部分圆的方法 15+i*30, //在map上的x轴的位置 15+j*30, //为在map上的y轴的位置 13, //13为圆的半径，也可以说是棋子的半径 0, //0为开始弧度，画圆这里就入参0 2*Math.PI ////PI为圆周率π，Math.PI = 3.14 = 180° 因为圆为360°，所以这里是2*Math.PI ); map.closePath(); //可以理解为棋子刻画完毕 var chess = map.createRadialGradient( //createRadialGradient()方法用来创建圆形渐变对象。 15+i*30+2, //渐变的开始圆的 x 坐标 15+j*30-2, //渐变的开始圆的 y 坐标 15, //开始圆的半径 15+i*30, //渐变的结束圆的 x 坐标 15+j*30, //渐变的结束圆的 y 坐标 0 //结束圆的半径 ); if(me == true){ //轮到我的时候时白子 chess.addColorStop(0,&quot;#0A0A0A&quot;); //addColorStop()定义一个颜色的渐变 chess.addColorStop(1,&quot;#636766&quot;); }else{ //其他时候时黑子 chess.addColorStop(0,&quot;#D1D1D1&quot;); chess.addColorStop(1,&quot;#F9F9F9&quot;); }; map.fillStyle = chess; //fillStyle属性设置或返回用于填充绘画的颜色、渐变或模式 map.fill() //fill()方法填充当前的图像 } //判断落子点 var canvasBoard = []; //判断谁落子 var me = true; //判断结束游戏 var over = false; //输赢统计数组 var my_win = []; var computer_win = []; //判断落子点 for(var i=0; i&lt;15; i++){ canvasBoard[i] = []; for(var j=0; j&lt;15; j++){ canvasBoard[i][j] = 0; } } //赢法数组 var wins = []; for(var i=0; i&lt;15; i++){ wins[i] = []; for(var j=0; j&lt;15; j++){ wins[i][j] = []; } } //统计所有可能的赢法 var count = 0; //横线 for(var i = 0; i &lt; 15; i++){ for(var j= 0; j &lt; 11; j++){ for(var k = 0; k &lt; 5; k++){ wins[i][j+k][count] = true; } count++; } } //竖线 for(var i = 0; i &lt; 15; i++){ for(var j= 0; j &lt; 11; j++){ for(var k = 0; k &lt; 5; k++){ wins[j+k][i][count] = true; } count++; } } //正斜 for(var i = 0; i &lt; 11; i++){ for(var j= 0; j &lt; 11; j++){ for(var k = 0; k &lt; 5; k++){ wins[i+k][j+k][count] = true; } count++; } } //反斜 for(var i = 0; i &lt; 11; i++){ for(var j= 14; j &gt; 3; j--){ for(var k = 0; k &lt; 5; k++){ wins[i+k][j-k][count] = true; } count++; } } //console.log(count) 15*15的棋盘中有572中赢法 //输赢统计数组 for (let i = 0; i &lt; count; i++) { my_win[i] = 0; computer_win[i] = 0; } //我落子 canvas.onclick = function(e){ if(over == true){ //over为true时执行，这时候游戏已经结束了，所以return个空气出去 =。 = return; } if(me == false){ //如果为!me，就是为false时，还没轮到我下棋，return个空气出去，让我动不了 return; } var x = e.offsetX; var y = e.offsetY; var i = parseInt(x/30); var j = parseInt(y/30); if(canvasBoard[i][j] == 0){ //为0时，证明这个位置是空的，是可以落子的 on(i,j,me); canvasBoard[i][j] = 1; //用1来表示我的落子 var a = setTimeout(() =&gt; { for (let k = 0; k &lt; count; k++){ //遍历所有赢法 if(wins[i][j][k]){ //如果我当前落子符合某个赢法 my_win[k]++; //计数器+1 computer_win[k] = 6; if ( my_win[k] == 5) { window.alert(&quot;you win!!&quot;) over = true; //游戏结束 } } } if(over == false){ //如果游戏没有结束 me = false; //me变成false 轮到切换到电脑来落子 var b = setTimeout(() =&gt; { computerAI(); //然后调用电脑AI clearTimeout(b); }, 800); } clearTimeout(a); }, 30); } } //接下来大概是最难IA落子 var computerAI = function(){ //积分设定 var myScroe = []; var computerScore = []; //落子的优先判定 var max = 0; //电脑的落子坐标 var u = 0,v = 0; //获得所有的格子,每个格子都有myScroe和computerScore且都为0用来给落子打分 for (let i = 0; i &lt; 15; i++) { myScroe[i] = []; computerScore[i] = []; for (let j = 0; j &lt; 15; j++) { myScroe[i][j] = 0; computerScore[i][j] = 0; } } //先获得每一个格子 for (let i = 0; i &lt; 15; i++){ for (let j = 0; j &lt; 15; j++){ //和人下棋一样,落子前得判定canvasBoard[i][j]为0,也就是没有任何棋子 if(canvasBoard[i][j] == 0){ //遍历全部的赢法 for (let k = 0; k &lt; count; k++){ //如果当前的wins[i][j][k]存在,并且有子的时候 if (wins[i][j][k]){ //接下来就是具体给每个落子打分 if (my_win[k] == 1){ myScroe[i][j] += 200; } else if(my_win[k] == 2){ myScroe[i][j] += 400; } else if(my_win[k] == 3){ myScroe[i][j] += 2000; } else if(my_win[k] == 4){ myScroe[i][j] += 10000; } //这里是给电脑落子打分 if (computer_win[k] == 1){ computerScore[i][j] += 300; } else if(computer_win[k] == 2){ computerScore[i][j] += 600; } else if(computer_win[k] == 3){ computerScore[i][j] += 4000; } else if(computer_win[k] == 4){ computerScore[i][j] += 20000; } } } //这段时用来判断落子的最佳处 //人在某一部权值更高的情况 if(myScroe[i][j] &gt; max){ max = myScroe[i][j]; u = i; v = j; } //权值已经到了最大的时候 else if(myScroe[i][j] == max){ //而i,j点的权值比在u,v点的更大时 if(computerScore[i][j] &gt; computerScore[u][v]){ u = i; v = j; } } //电脑在某一步权值更高时 else if(computerScore[i][j] &gt; max){ max = computerScore[i][j]; u = i; v = j; } //当权值最大的时候 else if(computerScore[i][j] == max){ //如果人电脑在此处落子更有用 if(myScroe[i][j] &gt; myScroe[u][v]){ u = i; v = j; } } } } } //当判断出最佳的落子点后,电脑开始落子,并且给落子点标记个2证明时白子 on(u,v,me); canvasBoard[u][v] = 2; //这里判断是否有五个子连成一线,和上面的判断大致一样 var b = setTimeout(() =&gt; { for (let k = 0; k &lt; count; k++) { if(wins[u][v][k]){ computer_win[k]++; my_win[k] = 6; if (computer_win[k] == 5) { on(u,v,me); over = true var a = setTimeout(() =&gt; { window.alert(&quot;you lose!!&quot;) clearTimeout(a); }, 30); } } } if(over == false){ me = true; } clearTimeout(b); }, 10); } &lt;/script&gt; 至于要具体的源码的朋友，可以去我的博客下载，链接在上一个博客里面有","categories":[{"name":"技术","slug":"技术","permalink":"https://hikigayahachima.github.io/categories/技术/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://hikigayahachima.github.io/tags/javaScript/"},{"name":"悦读","slug":"悦读","permalink":"https://hikigayahachima.github.io/tags/悦读/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://hikigayahachima.github.io/categories/技术/"}]},{"title":"五子棋--UI篇","slug":"五子棋-UI篇","date":"2019-05-20T06:00:03.000Z","updated":"2019-05-21T12:00:05.838Z","comments":true,"path":"2019/05/20/五子棋-UI篇/","link":"","permalink":"https://hikigayahachima.github.io/2019/05/20/五子棋-UI篇/","excerpt":"","text":"简介最近小组举行小游戏设计，我思来想去，还是选择了五子棋，具体原因嘛……当然是不会先围棋和象棋啊(╯‵□′)╯︵┻━┻，那个规则超麻烦的，还是五子棋简单方便🤣 UI篇的主要思路1.棋盘的实现​ 1）canvas绘画直线。 ​ 2）设置背景色。 2.棋子的实现​ 1) canvas画出棋子样子。 ​ 2）充填颜色，看起来更有立体感 一、正片区域1.棋盘的页面结构1）style样式 ​ 棋盘给出了个阴影效果，box-shadow，看起来更美观 *{ padding: 0px; margin: 0px; } #map { display: block; margin: 50px auto; box-shadow: -2px -2px 2px #EFEFEF, 5px 5px 5px #B9B9B9; } 2）棋盘主体 ​ canvas 为h5中的标签，用来定义图形，比如图表和其他图像，具体的使用方法可参考W3C文档 &lt;canvas id=&quot;map&quot; width=&quot;450px&quot; height=&quot;450px&quot;&gt;&lt;/canvas&gt; ​ 完成之后我们的页面效果是这样的 2.棋盘的网格绘制画棋盘的网格​ 这里用到JS来控制canvas画棋盘，我们知道五子棋的棋盘是由些纵线和横线组成的，棋盘的样子如下： ​ 分别有15条纵线和横线，每个格子为30px的正方形，棋盘边缘有15px的补白。 画线的方法​ 下面是canvas中画单根横线的方法 var canvas = document.querySelector(&quot;#map&quot;); //先获取到canvas //getContext() 方法返回一个用于在画布上绘图的环境。 目前只支持2d var map = canvas.getContext(&quot;2d&quot;); //strokeStyle是H5中用来规定画笔颜色的属性 map.strokeStyle = &quot;#111&quot;; //moveTo()是H5中用来画线的一个方法，moveTo()是线头起始的位置，里面传xy坐标 map.moveTo(15,15); //lineTo()于moveTo()对应，是规定线头结束的位置,里面传xy坐标 map.lineTo(435,15); stroke() 方法会实际地绘制出通过 moveTo() 和 lineTo() 方法定义的路径 map.stroke(); ​ 具体的效果如下 ​ 然后按照上面的思路，我们画15条横线和15条竖线 for (let i = 0; i &lt; 15; i++) { //横线 map.moveTo(15,15+i*30); map.lineTo(435,15+i*30); map.stroke(); //竖线 map.moveTo(15+i*30,15); map.lineTo(15+i*30,435); map.stroke(); } ​ 为了方便使用，我们将网格的绘画封装成一个函数 //获取地图画布 var canvas = document.querySelector(&quot;#map&quot;); var map = canvas.getContext(&quot;2d&quot;); map.strokeStyle = &quot;#111&quot;; //刻画棋盘 function context(){ for (let i = 0; i &lt; 15; i++) { //横线 map.moveTo(15,15+i*30); map.lineTo(435,15+i*30); map.stroke(); //竖线 map.moveTo(15+i*30,15); map.lineTo(15+i*30,435); map.stroke(); } } ​ 具体效果如下 ​ 格子画出来了，但是画面太单调了，那么接下来我们就来为棋盘添加背景。我们选择一张麻布色的图片，如果你想为棋盘添加你特有的水印，可以通过制图软件添加。 H5添加图片的方法是通过画图的方式，画上去就会覆盖掉之前画的网格，所以我们之前对画网格的代码进行封装成一个函数，画完背景后再调用画网格的函数来达到不被覆盖的效果。总的代码如下 //增添背景图 var img = document.createElement(&quot;img&quot;); img.src = &quot;./images/qipan.jpg&quot;; img.onload = function(){ map.drawImage(img,0,0,450,450) context(); } 具体效果如下 2.棋子的实现棋子的画法map.beginPath(); //可以理解为棋子刻画开始 map.arc( //用于创建圆或部分圆的方法 200, //在map上的x轴的位置 200, //为在map上的y轴的位置 100, //13为圆的半径，也可以说是棋子的半径 0, //0为开始弧度，画圆这里就入参0 2*Math.PI //PI为圆周率π，Math.PI = 3.14 = 180° 因为圆为360°，所以这里是 ); map.closePath(); //可以理解为棋子刻画完毕 map.fill() //fill()方法填充当前的图像 然后先看看页面效果 ​ 原本应该是黑色实心的圆形，可能是我浏览器显示出了问题，不过这个没问题 ​ 这个效果还不像棋子，棋子中间要有些发亮才行的，我们给棋子中间加一个亮度的渐变： 我们直接看全部代码，再解释其中重要的代码： //封装落子 function on(i,j,me){ map.beginPath(); //可以理解为棋子刻画开始 map.arc( //用于创建圆或部分圆的方法 15+i*30, //在map上的x轴的位置 15+j*30, //为在map上的y轴的位置 13, //13为圆的半径，也可以说是棋子的半径 0, //0为开始弧度，画圆这里就入参0 2*Math.PI //PI为圆周率π，Math.PI = 3.14 = 180° 因为圆为360°，所以这里是 ); map.closePath(); //可以理解为棋子刻画完毕 //createRadialGradient()方法用来创建圆形渐变对象。 var chess = map.createRadialGradient( 15+i*30+2, //渐变的开始圆的 x 坐标 15+j*30-2, //渐变的开始圆的 y 坐标 15, //开始圆的半径 15+i*30, //渐变的结束圆的 x 坐标 15+j*30, //渐变的结束圆的 y 坐标 0 //结束圆的半径 ); if(me == true){ //轮到我的时候时白子 chess.addColorStop(0,&quot;#0A0A0A&quot;); //addColorStop()定义一个颜色的渐变 chess.addColorStop(1,&quot;#636766&quot;); }else{ //其他时候时黑子 chess.addColorStop(0,&quot;#D1D1D1&quot;); chess.addColorStop(1,&quot;#F9F9F9&quot;); }; map.fillStyle = chess; //fillStyle属性设置或返回用于填充绘画的颜色、渐变或模式 map.fill() //fill()方法填充当前的图像 } ​ 上面是实现全部的黑白子的代码，createRadialGradient () 方法用来创建圆形渐变对象。 ​ 至于下面的代码区则是来区分黑白子的，定义一个变量me来决定是黑子还是白子，每点击一次就改变一次me的值，效果如下： ​ 这时候还有一个问题，已经下了黑子的点，重新点击还会被白子覆盖掉。那怎么解决呢？ ​ 首先我们定义一个二维数组，存放所有的落子点，如果有落子，就给其记录下来。落子的时候再判断是否已经落子，如果已经落子了就不允许重新落子。思路就是这样。 二维数组代码： //判断落子点 var canvasBoard = []; for(var i=0; i&lt;15; i++){ canvasBoard[i] = []; for(var j=0; j&lt;15; j++){ canvasBoard[i][j] = 0; } } ​ 我们先给每一个格子设定初始值为0，然后落子记录，代码如下 //我落子 canvas.onclick = function(e){ var x = e.offsetX; var y = e.offsetY; var i = parseInt(x/30); var j = parseInt(y/30); if(canvasBoard[i][j] == 0){ //为0时，证明这个位置是空的，是可以落子的 on(i,j,me); canvasBoard[i][j] = 1; //用1来表示黑子 }else{ canvasBoard[i][j] = 2; //用2来表示白子 } me = !me ; //这里用于判断黑白子 } ​ 落子位置等于0才可以落子，落完子后给相应的点附非0值，黑子就附1，白子附2。 效果： ​ 下面是UI篇全部的代码 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;script src=&quot;./style.js&quot;&gt;&lt;/script&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *{ padding: 0px; margin: 0px; } #map { display: block; margin: 50px auto; box-shadow: -2px -2px 2px #EFEFEF, 5px 5px 5px #B9B9B9; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=&quot;map&quot; width=&quot;450px&quot; height=&quot;450px&quot;&gt;&lt;/canvas&gt; &lt;/body&gt; &lt;script&gt; //获取地图画布 var canvas = document.querySelector(&quot;#map&quot;); var map = canvas.getContext(&quot;2d&quot;); map.strokeStyle = &quot;#111&quot;; //刻画棋盘 function context(){ for (let i = 0; i &lt; 15; i++) { //横线 map.moveTo(15,15+i*30); map.lineTo(435,15+i*30); map.stroke(); //竖线 map.moveTo(15+i*30,15); map.lineTo(15+i*30,435); map.stroke(); } } //增添背景图 var img = document.createElement(&quot;img&quot;); img.src = &quot;./images/qipan.jpg&quot;; img.onload = function(){ map.drawImage(img,0,0,450,450) context(); }; //封装落子 function on(i,j,me){ map.beginPath(); //可以理解为棋子刻画开始 map.arc( //用于创建圆或部分圆的方法 15+i*30, //在map上的x轴的位置 15+j*30, //为在map上的y轴的位置 13, //13为圆的半径，也可以说是棋子的半径 0, //0为开始弧度，画圆这里就入参0 2*Math.PI //PI为圆周率π，Math.PI = 3.14 = 180° 因为圆为360°，所以这里是 ); map.closePath(); //可以理解为棋子刻画完毕 var chess = map.createRadialGradient( //createRadialGradient()方法用来创建圆形渐变对象。 15+i*30+2, //渐变的开始圆的 x 坐标 15+j*30-2, //渐变的开始圆的 y 坐标 15, //开始圆的半径 15+i*30, //渐变的结束圆的 x 坐标 15+j*30, //渐变的结束圆的 y 坐标 0 //结束圆的半径 ); if(me == true){ //轮到我的时候时白子 chess.addColorStop(0,&quot;#0A0A0A&quot;); //addColorStop()定义一个颜色的渐变 chess.addColorStop(1,&quot;#636766&quot;); }else{ //其他时候时黑子 chess.addColorStop(0,&quot;#D1D1D1&quot;); chess.addColorStop(1,&quot;#F9F9F9&quot;); }; map.fillStyle = chess; //fillStyle属性设置或返回用于填充绘画的颜色、渐变或模式 map.fill() //fill()方法填充当前的图像 }; //判断落子点 var canvasBoard = []; for(var i=0; i&lt;15; i++){ canvasBoard[i] = []; for(var j=0; j&lt;15; j++){ canvasBoard[i][j] = 0; }; }; //判断黑白子 var me = true; //我落子 canvas.onclick = function(e){ var x = e.offsetX; var y = e.offsetY; var i = parseInt(x/30); var j = parseInt(y/30); if(canvasBoard[i][j] == 0){ //为0时，证明这个位置是空的，是可以落子的 on(i,j,me); canvasBoard[i][j] = 1; //用1来表示黑子 }else{ canvasBoard[i][j] = 2; //用2来表示白子 }; me = !me ; }; &lt;/script&gt; &lt;/html&gt; 总结 棋盘的实现 通过循环画直线 棋子的实现 画出你想要的棋子，渐变填充颜色，封装成一个函数供调用。 落子的实现 用数组存放每一个落子点，满足条件就落下对应的子。 UI篇到此就告一段落了，这里用到的知识并不多，相应的方法想了解更多可以到W3上看，如果想要源码的朋友可以去我的github上下载，https://github.com/HikigayaHachima/HikigayaHachima.github.io 。","categories":[{"name":"技术","slug":"技术","permalink":"https://hikigayahachima.github.io/categories/技术/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"https://hikigayahachima.github.io/tags/javaScript/"},{"name":"悦读","slug":"悦读","permalink":"https://hikigayahachima.github.io/tags/悦读/"},{"name":"css","slug":"css","permalink":"https://hikigayahachima.github.io/tags/css/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://hikigayahachima.github.io/categories/技术/"}]},{"title":"Hexo-Theme-Sakura","slug":"Hexo-Theme-Sakura","date":"2018-12-12T14:16:01.000Z","updated":"2019-05-16T14:39:12.000Z","comments":true,"path":"2018/12/12/Hexo-Theme-Sakura/","link":"","permalink":"https://hikigayahachima.github.io/2018/12/12/Hexo-Theme-Sakura/","excerpt":"","text":"hexo-theme-sakura主题 English document 基于WordPress主题Sakura修改成Hexo的主题。 demo预览 正在开发中…… 交流群若你是使用者，加群QQ: 801511924 若你是创作者，加群QQ: 194472590 主题特性 首页大屏视频 首页随机封面 图片懒加载 valine评论 fancy-box相册 pjax支持，音乐不间断 aplayer音乐播放器 多级导航菜单（按现在大部分hexo主题来说，这也算是个特性了） 赞赏作者如果喜欢hexo-theme-sakura主题，可以考虑资助一下哦~非常感激！ paypal | Alipay 支付宝 | WeChat Pay 微信支付 未完善的使用教程那啥？老实说我目前也不是很有条理233333333~ 1、主题下载安装hexo-theme-sakura建议下载压缩包格式，因为除了主题内容还有些source的配置对新手来说比较太麻烦，直接下载解压就省去这些麻烦咯。 下载好后解压到博客根目录（不是主题目录哦，重复的选择替换）。接着在命令行（cmd、bash）运行npm i安装依赖。 2、主题配置博客根目录下的_config配置站点 # Site title: 你的站点名 subtitle: description: 站点简介 keywords: author: 作者名 language: zh-cn timezone: 部署 deploy: type: git repo: github: 你的github仓库地址 # coding: 你的coding仓库地址 branch: master 备份 （使用hexo b发布备份到远程仓库） backup: type: git message: backup my blog of https://honjun.github.io/ repository: # 你的github仓库地址,备份分支名 （建议新建backup分支） github: https://github.com/honjun/honjun.github.io.git,backup # coding: https://git.coding.net/hojun/hojun.git,backup 主题目录下的_config配置其中标明【改】的是需要修改部门，标明【选】是可改可不改，标明【非】是不用改的部分 # site name # 站点名 【改】 prefixName: さくら荘その siteName: hojun # favicon and site master avatar # 站点的favicon和头像 输入图片路径（下面的配置是都是cdn的相对路径，没有cdn请填写完整路径，建议使用jsdeliver搭建一个cdn啦，先去下载我的cdn替换下图片就行了，简单方便~）【改】 favicon: /images/favicon.ico avatar: /img/custom/avatar.jpg # 站点url 【改】 url: https://sakura.hojun.cn # 站点介绍（或者说是个人签名）【改】 description: Live your life with passion! With some drive! # 站点cdn，没有就为空 【改】 若是cdn为空，一些图片地址就要填完整地址了，比如之前avatar就要填https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/custom/avatar.jpg cdn: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6 # 开启pjax 【选】 pjax: 1 # 站点首页的公告信息 【改】 notice: hexo-Sakura主题已经开源，目前正在开发中... # 懒加载的加载中图片 【选】 lazyloadImg: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg # 站点菜单配置 【选】 menus: 首页: { path: /, fa: fa-fort-awesome faa-shake } 归档: { path: /archives, fa: fa-archive faa-shake, submenus: { 技术: {path: /categories/技术/, fa: fa-code }, 生活: {path: /categories/生活/, fa: fa-file-text-o }, 资源: {path: /categories/资源/, fa: fa-cloud-download }, 随想: {path: /categories/随想/, fa: fa-commenting-o }, 转载: {path: /categories/转载/, fa: fa-book } } } 清单: { path: javascript:;, fa: fa-list-ul faa-vertical, submenus: { 书单: {path: /tags/悦读/, fa: fa-th-list faa-bounce }, 番组: {path: /bangumi/, fa: fa-film faa-vertical }, 歌单: {path: /music/, fa: fa-headphones }, 图集: {path: /tags/图集/, fa: fa-photo } } } 留言板: { path: /comment/, fa: fa-pencil-square-o faa-tada } 友人帐: { path: /links/, fa: fa-link faa-shake } 赞赏: { path: /donate/, fa: fa-heart faa-pulse } 关于: { path: /, fa: fa-leaf faa-wrench , submenus: { 我？: {path: /about/, fa: fa-meetup}, 主题: {path: /theme-sakura/, fa: iconfont icon-sakura }, Lab: {path: /lab/, fa: fa-cogs }, } } 客户端: { path: /client/, fa: fa-android faa-vertical } RSS: { path: /atom.xml, fa: fa-rss faa-pulse } # Home page sort type: -1: newer first，1: older first. 【非】 homePageSortType: -1 # Home page article shown number) 【非】 homeArticleShown: 10 # 背景图片 【选】 bgn: 8 # startdash面板 url, title, desc img 【改】 startdash: - {url: /theme-sakura/, title: Sakura, desc: 本站 hexo 主题, img: /img/startdash/sakura.md.png} - {url: http://space.bilibili.com/271849279, title: Bilibili, desc: 博主的b站视频, img: /img/startdash/bilibili.jpg} - {url: /, title: hojun的万事屋, desc: 技术服务, img: /img/startdash/wangshiwu.jpg} # your site build time or founded date # 你的站点建立日期 【改】 siteBuildingTime: 07/17/2018 # 社交按钮(social) url, img PC端配置 【改】 social: github: {url: http://github.com/honjun, img: /img/social/github.png} sina: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/sina.png} wangyiyun: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/wangyiyun.png} zhihu: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/zhihu.png} email: {url: http://weibo.com/mashirozx?is_all=1, img: /img/social/email.svg} wechat: {url: /#, qrcode: /img/custom/wechat.jpg, img: /img/social/wechat.png} # 社交按钮(msocial) url, img 移动端配置 【改】 msocial: github: {url: http://github.com/honjun, fa: fa-github, color: 333} weibo: {url: http://weibo.com/mashirozx?is_all=1, fa: fa-weibo, color: dd4b39} qq: {url: https://wpa.qq.com/msgrd?v=3&amp;uin=954655431&amp;site=qq&amp;menu=yes, fa: fa-qq, color: 25c6fe} # 赞赏二维码（其中wechatSQ是赞赏单页面的赞赏码图片）【改】 donate: alipay: /img/custom/donate/AliPayQR.jpg wechat: /img/custom/donate/WeChanQR.jpg wechatSQ: /img/custom/donate/WeChanSQ.jpg # 首页视频地址为https://cdn.jsdelivr.net/gh/honjun/hojun@1.2/Unbroken.mp4，配置如下 【改】 movies: url: https://cdn.jsdelivr.net/gh/honjun/hojun@1.2 # 多个视频用逗号隔开，随机获取。支持的格式目前已知MP4,Flv。其他的可以试下，不保证有用 name: Unbroken.mp4 # 左下角aplayer播放器配置 主要改id和server这两项，修改详见[aplayer文档] 【改】 aplayer: id: 2660651585 server: netease type: playlist fixed: true mini: false autoplay: false loop: all order: random preload: auto volume: 0.7 mutex: true # Valine评论配置【改】 valine: true v_appId: GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz v_appKey: mgOpfzbkHYqU92CV4IDlAUHQ 分类页和标签页配置分类页 标签页 配置项在\\themes\\Sakura\\languages\\zh-cn.yml里。新增一个分类或标签最好加下哦，当然嫌麻烦可以直接使用一张默认图片（可以改主题或者直接把404图片替换下，征求下意见要不要给这个在配置文件中加个开关，可以issue或群里提出来），现在是没设置的话会使用那种倒立小狗404哦。 #category # 按分类名创建 技术: #中文标题 zh: 野生技术协会 # 英文标题 en: Geek – Only for Love # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/coding.jpg 生活: zh: 生活 en: live img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/writing.jpg #tag # 标签名即是标题 悦读: # 封面图片 img: https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/banner/reading.jpg 单页面封面配置如留言板页面页面，位于source下的comment下，打开index.md如下： --- title: comment date: 2018-12-20 23:13:48 keywords: 留言板 description: comments: true # 在这里配置单页面头部图片，自定义替换哦~ photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/comment.jpg --- 单页面配置番组计划页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: bangumi title: bangumi comments: false date: 2019-02-10 21:32:48 keywords: description: bangumis: # 番组图片 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg # 番组名 title: 朝花夕誓——于离别之朝束起约定之花 # 追番状态 （追番ing/已追完） status: 已追完 # 追番进度 progress: 100 # 番剧日文名称 jp: さよならの朝に約束の花をかざろう # 放送时间 time: 放送时间: 2018-02-24 SUN. # 番剧介绍 desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 - img: https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg title: 朝花夕誓——于离别之朝束起约定之花 status: 已追完 progress: 50 jp: さよならの朝に約束の花をかざろう time: 放送时间: 2018-02-24 SUN. desc: 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。 --- 友链页 （请直接在下载后的文件中改，下面的添加了注释可能会有些影响） --- layout: links title: links # 创建日期，可以改下 date: 2018-12-19 23:11:06 # 图片上的标题，自定义修改 keywords: 友人帐 description: # true/false 开启/关闭评论 comments: true # 页面头部图片，自定义修改 photos: https://cdn.jsdelivr.net/gh/honjun/cdn@1.4/img/banner/links.jpg # 友链配置 links: # 类型分组 - group: 个人项目 # 类型简介 desc: 充分说明这家伙是条咸鱼 &lt; (￣︶￣)&gt; items: # 友链链接 - url: https://shino.cc/fgvf # 友链头像 img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg # 友链站点名 name: Google # 友链介绍 下面雷同 desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 # 类型分组... - group: 小伙伴们 desc: 欢迎交换友链 ꉂ(ˊᗜˋ) items: - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 - url: https://shino.cc/fgvf img: https://cloud.moezx.cc/Picture/svg/landscape/fields.svg name: Google desc: Google 镜像 --- 写文章配置主题集成了个人插件hexo-tag-bili和hexo-tag-fancybox_img。其中hexo-tag-bili用来在文章或单页面中插入B站外链视频，使用语法如下： {% bili video_id [page] %} 详细使用教程详见hexo-tag-bili。 hexo-tag-fancybox_img用来在文章或单页面中图片，使用语法如下： {% fb_img src [caption] %} 详细使用教程详见hexo-tag-fancybox_img 还有啥，一时想不起来……To be continued…","categories":[{"name":"技术","slug":"技术","permalink":"https://hikigayahachima.github.io/categories/技术/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://hikigayahachima.github.io/tags/悦读/"},{"name":"web","slug":"web","permalink":"https://hikigayahachima.github.io/tags/web/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://hikigayahachima.github.io/categories/技术/"}]}]}